/* vim:set noexpandtab tabstop=4 wrap filetype=cpp */
#ifndef PlotNeutronCaptures_H
#define PlotNeutronCaptures_H

#include <string>
#include <iostream>

#include "Tool.h"
#include "MTreeReader.h"
#include "SkrootHeaders.h" // MCInfo, Header etc.

class TApplication;
class TFile;
class TTree;
class TVector3;
class TLorentzVector;

/**
* \class PlotNeutronCaptures
*
* This tool makes plots from the files generated by the TruthNeutronCaptures tool to characterise neutron captures
*
* $Author: M.O'Flahery $
* $Date: 2020/08/12 $
* Contact: marcus.o-flaherty@warwick.ac.uk
*/
class PlotNeutronCaptures: public Tool {
	
	public:
	PlotNeutronCaptures(); ///< Simple constructor
	bool Initialise(std::string configfile,DataModel &data); ///< Initialise Function for setting up Tool resorces. @param configfile The path and name of the dynamic configuration file to read in. @param data A reference to the transient data class used to pass information between Tools.
	bool Execute();        ///< Executre function used to perform Tool perpose. 
	bool Finalise();       ///< Finalise funciton used to clean up resorces.
	
	private:
	// functions
	// =========
	int ReadEntry(long entry_number);
	int GetBranches();
	int FillHistos();
	
	// tool variables
	// ==============
	std::string toolName;
	bool DrawPlots;
	TApplication* rootTApp;
	std::string inputFile;
	std::string outputFile; // or just add to the input file?
	int maxEvents;
	
	int entrynum;
	
	// verbosity levels: if 'verbosity' < this level, the message type will be logged.
	int verbosity=1;
	int v_error=0;
	int v_warning=1;
	int v_message=2;
	int v_debug=3;
	std::string logmessage="";
	int get_ok=0;
	
	// variables to read in
	// ====================
	MTreeReader myTreeReader; // the TTree reader
	
	// file-wise
	std::string filename;
	float water_transparency;
	
	// event-wise
	int entry_number;     // TTree entry number to be able to identify the source event
	int subevent_number;  // 
	
	// primary particle - an event can have many primary particles
	std::vector<int> primary_pdg;                                 // 
	std::vector<double> primary_energy;                           // [MeV]
	std::vector<TLorentzVector> primary_start_pos;                // [cm, ns]
	std::vector<TLorentzVector> primary_end_pos;                  // [cm, ns]
	
	// parent nuclide - potentially many per event
	std::vector<int> nuclide_pdg;
	std::vector<TLorentzVector> nuclide_creation_pos;              // [cm, ns]
	std::vector<TLorentzVector> nuclide_decay_pos;                 // [cm, ns]
	std::vector<int> nuclide_daughter_pdg;                         // 
	
	// neutrons  - potentially many per nuclide? or just one?
	std::vector<std::vector<TLorentzVector> > neutron_start_pos;   // [cm, ns]
	std::vector<std::vector<TLorentzVector> > neutron_end_pos;     // [cm, ns]
	std::vector<std::vector<double> > neutron_start_energy;        // [MeV]
	std::vector<std::vector<double> > neutron_end_energy;          // [MeV] - on capture/decay
	std::vector<std::vector<int> > neutron_end_process;            // geant3 process code
	std::vector<std::vector<int> >neutron_ndaughters;              // num gammas
	
	// gammas - potentially many per neutron
	std::vector<std::vector<std::vector<double> > > gamma_energy;  // [MeV]
	std::vector<std::vector<std::vector<double> > > gamma_time;    // [ns]
	
	// detector information
	// total charge? time distribution of hits?
	// build a timestamp and calculate time since last event? using PrevT0?
	
};


#endif
